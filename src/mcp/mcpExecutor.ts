import { Page } from "playwright";
import { Action, ActionResult, ElementInfo } from "../types/actions.js";
import { captureScreenshot } from "../browser/screenshot.js";
import { MCPBrowserClient, MCPToolResult } from "./mcpClient.js";

/**
 * Extended ActionResult that includes MCP-generated Playwright code.
 */
export interface MCPActionResult extends ActionResult {
  /** Playwright code auto-generated by the MCP tool for this action */
  generatedCode?: string;
}

/**
 * Executes actions via Playwright MCP tools instead of direct Playwright calls.
 *
 * The MCP tools both execute the action AND return the Playwright code
 * they used â€” giving us proper locators (getByRole, getByText, etc.)
 * for free.
 *
 * Falls back to direct Playwright execution when MCP tools fail.
 */
export class MCPExecutor {
  private page: Page;
  private mcpClient: MCPBrowserClient;
  private lastSnapshot: string | undefined;

  constructor(page: Page, mcpClient: MCPBrowserClient) {
    this.page = page;
    this.mcpClient = mcpClient;
  }

  /**
   * Execute an action and return the result with MCP-generated code.
   */
  async execute(action: Action): Promise<MCPActionResult> {
    const timestamp = Date.now();

    try {
      const result = await this.executeViaMCP(action);

      await this.waitForScreenshotJitter();
      const screenshot = await captureScreenshot(this.page);

      return {
        action,
        screenshot,
        generatedCode: result.generatedCode,
        elementInfo: undefined, // MCP doesn't return ElementInfo in our format
        error: result.error,
        timestamp,
      };
    } catch (error) {
      await this.waitForScreenshotJitter();
      const screenshot = await captureScreenshot(this.page);

      return {
        action,
        screenshot,
        error: error instanceof Error ? error.message : String(error),
        timestamp,
      };
    }
  }

  /**
   * Map our Action type to MCP tool calls and execute.
   */
  private async executeViaMCP(
    action: Action
  ): Promise<{ generatedCode?: string; error?: string }> {
    switch (action.type) {
      case "click": {
        const result = await this.mcpClient.callTool(
          "browser_mouse_click_xy",
          {
            element: "click target",
            x: action.x,
            y: action.y,
          }
        );
        return this.processResult(result);
      }

      case "double_click": {
        // MCP mouse_click_xy doesn't support doubleClick directly,
        // fall back to direct Playwright
        await this.page.mouse.dblclick(action.x, action.y);
        return {
          generatedCode: `await page.mouse.dblclick(${action.x}, ${action.y});`,
        };
      }

      case "click_button": {
        // Take snapshot to find the button's ref in the a11y tree
        const ref = await this.findRefByRole(
          "button",
          action.name,
          action.exact ?? true
        );
        if (ref) {
          const result = await this.mcpClient.callTool("browser_click", {
            element: `button "${action.name}"`,
            ref,
          });
          return this.processResult(result);
        }
        // Fallback: use direct Playwright
        const locator = this.page.getByRole("button", {
          name: action.name,
          exact: action.exact ?? true,
        });
        await locator.first().click();
        return {
          generatedCode: `await page.getByRole('button', { name: '${escapeString(action.name)}', exact: ${action.exact ?? true} }).click();`,
        };
      }

      case "click_text": {
        // Take snapshot to find the element's ref
        const ref = await this.findRefByText(
          action.text,
          action.exact ?? false
        );
        if (ref) {
          const result = await this.mcpClient.callTool("browser_click", {
            element: `text "${action.text}"`,
            ref,
          });
          return this.processResult(result);
        }
        // Fallback: direct Playwright
        await this.page
          .getByText(action.text, { exact: action.exact ?? false })
          .first()
          .click();
        return {
          generatedCode: `await page.getByText('${escapeString(action.text)}', { exact: ${action.exact ?? false} }).first().click();`,
        };
      }

      case "select_input": {
        // Find the input's ref and use browser_type to fill it
        const ref = await this.findRefByLabel(action.field, action.exact ?? true);
        if (ref) {
          // Click first to focus, then fill
          const clickResult = await this.mcpClient.callTool("browser_click", {
            element: `input "${action.field}"`,
            ref,
          });
          const typeResult = await this.mcpClient.callTool("browser_type", {
            element: `input "${action.field}"`,
            ref,
            text: action.value,
          });
          // Combine the generated code
          const clickCode = clickResult.isError
            ? undefined
            : clickResult.generatedCode;
          const typeCode = typeResult.isError
            ? undefined
            : typeResult.generatedCode;
          const combined = [clickCode, typeCode].filter(Boolean).join("\n");
          return {
            generatedCode: combined || undefined,
            error: typeResult.error,
          };
        }
        // Fallback: direct Playwright
        await this.fillInputByField(action.field, action.value, action.exact ?? true);
        return {
          generatedCode: `await fillInputByField(page, '${escapeString(action.field)}', '${escapeString(action.value)}', ${action.exact ?? true});`,
        };
      }

      case "type": {
        const result = await this.mcpClient.callTool("browser_press_key", {
          key: action.text,
        });
        // browser_press_key is for single keys, for text we need keyboard.type
        // Fall back to direct Playwright for multi-char text
        if (action.text.length > 1) {
          await this.page.keyboard.type(action.text);
          return {
            generatedCode: `await page.keyboard.type('${escapeString(action.text)}');`,
          };
        }
        return this.processResult(result);
      }

      case "key": {
        const result = await this.mcpClient.callTool("browser_press_key", {
          key: normalizeKeyCombo(action.key),
        });
        return this.processResult(result);
      }

      case "scroll": {
        // MCP doesn't have a dedicated scroll tool
        // Execute directly via Playwright
        await this.page.mouse.move(action.x, action.y);
        const delta =
          (action.amount || 100) * (action.direction === "up" ? -1 : 1);
        await this.page.mouse.wheel(0, delta);
        return {
          generatedCode: `await page.mouse.wheel(0, ${delta});`,
        };
      }

      case "wait": {
        if (action.ms >= 2000) {
          // Use MCP wait_for with time
          const seconds = action.ms / 1000;
          const result = await this.mcpClient.callTool("browser_wait_for", {
            time: seconds,
          });
          return this.processResult(result);
        }
        await this.page.waitForTimeout(action.ms);
        return {
          generatedCode: `await page.waitForTimeout(${action.ms});`,
        };
      }

      case "assert_text": {
        const result = await this.mcpClient.callTool(
          "browser_verify_text_visible",
          { text: action.text }
        );
        return this.processResult(result);
      }

      case "assert_visible": {
        // MCP verify needs role+name, but we only have coordinates.
        // Fall back to direct Playwright
        const elementInfo = await this.getElementAtPoint(action.x, action.y);
        if (elementInfo?.role && (elementInfo.name || elementInfo.ariaLabel)) {
          const result = await this.mcpClient.callTool(
            "browser_verify_element_visible",
            {
              role: elementInfo.role,
              accessibleName: elementInfo.ariaLabel || elementInfo.name || "",
            }
          );
          return this.processResult(result);
        }
        // Minimal fallback
        return {
          generatedCode: `await assertVisibleAtPoint(page, ${action.x}, ${action.y});`,
        };
      }

      case "mouse_move":
        await this.page.mouse.move(action.x, action.y);
        return {};

      case "mouse_down":
        await this.page.mouse.move(action.x, action.y);
        await this.page.mouse.down({ button: action.button || "left" });
        return {};

      case "mouse_up":
        await this.page.mouse.move(action.x, action.y);
        await this.page.mouse.up({ button: action.button || "left" });
        return {};

      case "drag": {
        const result = await this.mcpClient.callTool(
          "browser_mouse_drag_xy",
          {
            element: "drag",
            startX: action.startX,
            startY: action.startY,
            endX: action.endX,
            endY: action.endY,
          }
        );
        return this.processResult(result);
      }

      case "screenshot":
      case "done":
        return {};

      default:
        return {};
    }
  }

  /**
   * Process an MCP tool result into generatedCode + error.
   */
  private processResult(result: MCPToolResult): {
    generatedCode?: string;
    error?: string;
  } {
    return {
      generatedCode: result.generatedCode,
      error: result.error,
    };
  }

  /**
   * Find an element ref in the accessibility snapshot by role and name.
   */
  private async findRefByRole(
    role: string,
    name: string,
    exact: boolean
  ): Promise<string | undefined> {
    const snapshot = await this.getSnapshot();
    if (!snapshot) return undefined;
    return findRefInSnapshot(snapshot, role, name, exact);
  }

  /**
   * Find an element ref by text content.
   */
  private async findRefByText(
    text: string,
    exact: boolean
  ): Promise<string | undefined> {
    const snapshot = await this.getSnapshot();
    if (!snapshot) return undefined;
    return findRefByTextInSnapshot(snapshot, text, exact);
  }

  /**
   * Find an input element ref by label text.
   */
  private async findRefByLabel(
    label: string,
    exact: boolean
  ): Promise<string | undefined> {
    const snapshot = await this.getSnapshot();
    if (!snapshot) return undefined;
    // Try textbox role first, then any input-like role
    return (
      findRefInSnapshot(snapshot, "textbox", label, exact) ||
      findRefInSnapshot(snapshot, "searchbox", label, exact) ||
      findRefInSnapshot(snapshot, "combobox", label, exact)
    );
  }

  /**
   * Get (cached) accessibility snapshot.
   * Cache invalidated after each action execution.
   */
  private async getSnapshot(): Promise<string | undefined> {
    if (!this.lastSnapshot) {
      try {
        this.lastSnapshot = await this.mcpClient.snapshot();
      } catch {
        return undefined;
      }
    }
    const result = this.lastSnapshot;
    // Invalidate cache so next action gets fresh snapshot
    this.lastSnapshot = undefined;
    return result;
  }

  /**
   * Wait for page to become stable (network idle).
   */
  async waitForStable(): Promise<void> {
    try {
      await this.page.waitForLoadState("networkidle", { timeout: 5000 });
    } catch {
      // Timeout is okay
    }
  }

  private async waitForScreenshotJitter(): Promise<void> {
    const delayMs = 300 + Math.floor(Math.random() * 701);
    await this.page.waitForTimeout(delayMs);
  }

  /**
   * Direct Playwright fillInputByField fallback (same as BrowserExecutor).
   */
  private async fillInputByField(
    field: string,
    value: string,
    exact: boolean
  ): Promise<void> {
    const candidates = [
      this.page.getByLabel(field, { exact }),
      this.page.getByPlaceholder(field, { exact }),
      this.page.getByRole("textbox", { name: field, exact }),
    ];
    for (const locator of candidates) {
      if ((await locator.count()) > 0) {
        await locator.first().click();
        await locator.first().fill(value);
        return;
      }
    }
    throw new Error(`No input found for field: ${field}`);
  }

  /**
   * Get element info at a point (for assert_visible fallback).
   */
  private async getElementAtPoint(
    x: number,
    y: number
  ): Promise<ElementInfo | undefined> {
    try {
      return await this.page.evaluate(
        ({ x, y }) => {
          const el = document.elementFromPoint(x, y);
          if (!el) return null;
          return {
            tagName: el.tagName.toLowerCase(),
            text: el.textContent?.trim().slice(0, 100),
            role: el.getAttribute("role") || undefined,
            name: el.getAttribute("aria-label") || undefined,
            id: el.id || undefined,
            className:
              typeof el.className === "string" ? el.className : undefined,
            ariaLabel: el.getAttribute("aria-label") || undefined,
            selector: el.tagName.toLowerCase(),
          };
        },
        { x, y }
      ) as ElementInfo | undefined;
    } catch {
      return undefined;
    }
  }
}

/**
 * Parse an accessibility snapshot YAML to find an element ref by role and name.
 *
 * Snapshot format example:
 *   - button "Submit" [ref=s3e5]
 *   - textbox "Email" [ref=s3e7]
 *   - heading "Welcome" [ref=s3e1]
 */
function findRefInSnapshot(
  snapshot: string,
  role: string,
  name: string,
  exact: boolean
): string | undefined {
  const lines = snapshot.split("\n");
  const nameLower = name.toLowerCase();

  for (const line of lines) {
    const trimmed = line.trim();
    // Match pattern: - role "name" [ref=...]
    // or: - role "name": content [ref=...]
    const rolePattern = new RegExp(
      `^-\\s+${escapeRegex(role)}\\s+"([^"]*)"`,
      "i"
    );
    const match = trimmed.match(rolePattern);
    if (!match) continue;

    const elementName = match[1];
    const matches = exact
      ? elementName === name
      : elementName.toLowerCase().includes(nameLower);

    if (matches) {
      const refMatch = trimmed.match(/\[ref=(s\w+)\]/);
      if (refMatch) return refMatch[1];
    }
  }

  return undefined;
}

/**
 * Find an element ref by text content in the snapshot.
 */
function findRefByTextInSnapshot(
  snapshot: string,
  text: string,
  exact: boolean
): string | undefined {
  const lines = snapshot.split("\n");
  const textLower = text.toLowerCase();

  for (const line of lines) {
    const trimmed = line.trim();
    // Check if the line contains the text
    const lineText = trimmed.replace(/\[ref=s\w+\]/g, "").trim();
    const matches = exact
      ? lineText.includes(`"${text}"`) || lineText.endsWith(`: ${text}`)
      : lineText.toLowerCase().includes(textLower);

    if (matches) {
      const refMatch = trimmed.match(/\[ref=(s\w+)\]/);
      if (refMatch) return refMatch[1];
    }
  }

  return undefined;
}

function escapeRegex(str: string): string {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

function escapeString(str: string): string {
  return str
    .replace(/\\/g, "\\\\")
    .replace(/'/g, "\\'")
    .replace(/\n/g, "\\n")
    .replace(/\r/g, "\\r")
    .replace(/\t/g, "\\t");
}

function normalizeKeyCombo(rawKey: string): string {
  const trimmed = rawKey.trim();
  if (!trimmed) return "Enter";

  const hasPlus = trimmed.includes("+");
  const hasDashModifiers =
    /(^|[-])(cmd|command|meta|ctrl|control|alt|option|shift)-/i.test(trimmed);
  const delimiter = hasPlus ? "+" : hasDashModifiers ? "-" : null;
  const parts = delimiter ? trimmed.split(delimiter) : [trimmed];

  const normalized = parts
    .map((part) => {
      const token = part.trim();
      if (!token) return "";
      const lower = token.toLowerCase();
      switch (lower) {
        case "cmd":
        case "command":
        case "meta":
          return "Meta";
        case "ctrl":
        case "control":
          return "Control";
        case "alt":
        case "option":
          return "Alt";
        case "shift":
          return "Shift";
        case "esc":
          return "Escape";
        case "return":
          return "Enter";
        case "space":
        case "spacebar":
          return "Space";
        case "del":
          return "Delete";
        default:
          return token.length === 1 ? token.toUpperCase() : token;
      }
    })
    .filter(Boolean);

  return normalized.join("+") || "Enter";
}
