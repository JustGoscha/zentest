import * as fs from "fs";
import { Test, TestSuite } from "../runner/testParser.js";
import { RecordedStep, Action, ElementInfo } from "../types/actions.js";
import type { AutomationMode } from "../config/loader.js";

export interface TestResult {
  test: Test;
  steps: RecordedStep[];
}

export interface SerializedSuiteSteps {
  automationMode?: AutomationMode;
  generatedAt?: string;
  tests: Array<{ name: string; steps: RecordedStep[] }>;
}

/**
 * The Test Builder observes the Agentic Tester's actions
 * and generates a Playwright test file.
 */
export class TestBuilder {
  private suiteName: string;
  private testName: string;
  private automationMode: AutomationMode;
  private readonly postClickWaitMs = 250;

  constructor(suiteName: string, testName: string, automationMode: AutomationMode = "vision") {
    this.suiteName = suiteName;
    this.testName = testName;
    this.automationMode = automationMode;
  }

  /**
   * Save recorded steps as a JSON sidecar file alongside the .spec.js.
   * Used by the healer to replay passing tests instead of re-running them agentically.
   */
  static saveSuiteSteps(stepsPath: string, testResults: TestResult[], automationMode: AutomationMode = "vision"): void {
    const serializable: SerializedSuiteSteps = {
      automationMode,
      generatedAt: new Date().toISOString(),
      tests: testResults.map(({ test, steps }) => ({
        name: test.name,
        // Strip screenshot buffers — they can't be JSON-serialized
        steps: steps.map(({ screenshot, ...rest }) => rest),
      })),
    };
    fs.writeFileSync(stepsPath, JSON.stringify(serializable, null, 2));
  }

  /**
   * Load previously saved suite steps from a JSON sidecar file.
   * Returns null if the file doesn't exist or can't be parsed.
   */
  static loadSuiteSteps(
    stepsPath: string
  ): SerializedSuiteSteps | null {
    try {
      const raw = fs.readFileSync(stepsPath, "utf-8");
      return JSON.parse(raw) as SerializedSuiteSteps;
    } catch {
      return null;
    }
  }

  /**
   * Generate a Playwright test from recorded steps
   */
  generate(steps: RecordedStep[], test: Test): string {
    const lines: string[] = [
      `import { test, expect } from '@playwright/test';`,
      ``,
      `async function loadZentestConfig() {`,
      `  try {`,
      `    const configUrl = new URL('../../zentest.config.js', import.meta.url);`,
      `    const loaded = await import(configUrl.href);`,
      `    return (loaded && loaded.default) || loaded || {};`,
      `  } catch {`,
      `    return {};`,
      `  }`,
      `}`,
      ``,
      ...this.buildReplayHelpers(),
      ``,
      ...this.buildDescriptionComment(test.description),
      `test('${test.name}', async ({ page }) => {`,
      `  test.setTimeout(20_000);`,
      `  const zentestConfig = await loadZentestConfig();`,
      `  const envName = process.env.ZENTEST_ENV;`,
      `  const envUrl = envName ? zentestConfig.environments?.[envName]?.url : undefined;`,
      `  const baseUrl = envUrl || process.env.ZENTEST_BASE_URL || zentestConfig.baseUrl;`,
      `  if (!baseUrl) {`,
      `    throw new Error('baseUrl is required to run static tests. Set it in zentest.config.js or use ZENTEST_ENV to select an environment.');`,
      `  }`,
      `  await page.goto(baseUrl, { waitUntil: 'networkidle' });`,
    ];

    const seenAssertions = new Set<string>();
    const hasTextAssertion = steps.some((s) => s.action.type === "assert_text");

    for (const step of steps) {
      // Skip steps that errored during the agentic run
      if (step.error) {
        continue;
      }

      const code = this.stepToCode(step);
      if (code) {
        // Deduplicate identical assertions
        const isAssertion = step.action.type === "assert_visible" || step.action.type === "assert_text";
        if (hasTextAssertion && step.action.type === "assert_visible") {
          continue; // Prefer text assertions over visibility-only checks
        }
        if (isAssertion && seenAssertions.has(code)) {
          continue; // Skip duplicate assertion
        }

        if (isAssertion) {
          seenAssertions.add(code);
        }

        // Add reasoning as comment
        if (step.reasoning) {
          lines.push(`  // ${step.reasoning.slice(0, 80)}`);
        }
        lines.push(`  ${code}`);
      }
    }

    lines.push(`});`);
    lines.push(``);

    return lines.join("\n");
  }

  /**
   * Generate a Playwright test suite from multiple tests
   * Uses test.describe.serial() so tests run in order and share browser state
   */
  generateSuite(testResults: TestResult[], suite: TestSuite): string {
    const modeLabel = this.automationMode === "mcp"
      ? "mcp (Playwright MCP tools — auto-generated locators)"
      : "vision (screenshot-based code generation)";
    const lines: string[] = [
      `// Generated by zentest | mode: ${modeLabel} | ${new Date().toISOString()}`,
      `import { test, expect } from '@playwright/test';`,
      ``,
      ...this.buildConfigLoader(),
      ``,
      ...this.buildReplayHelpers(),
      ``,
      `test.describe.serial('${this.escapeString(suite.name)}', () => {`,
      `  let baseUrl;`,
      `  let page;`,
      ``,
      `  test.beforeAll(async ({ browser }) => {`,
      `    const zentestConfig = await loadZentestConfig();`,
      `    const envName = process.env.ZENTEST_ENV;`,
      `    const envUrl = envName ? zentestConfig.environments?.[envName]?.url : undefined;`,
      `    baseUrl = envUrl || process.env.ZENTEST_BASE_URL || zentestConfig.baseUrl;`,
      `    if (!baseUrl) {`,
      `      throw new Error('baseUrl is required to run static tests. Set it in zentest.config.js or use ZENTEST_ENV to select an environment.');`,
      `    }`,
      `    page = await browser.newPage();`,
      `  });`,
      ``,
      `  test.afterAll(async () => {`,
      `    await page.close();`,
      `  });`,
      ``,
    ];

    let isFirst = true;
    for (const { test, steps } of testResults) {
      lines.push(...this.buildTestBlock(test, steps, isFirst));
      isFirst = false;
    }

    lines.push(`});`);
    lines.push(``);

    return lines.join("\n");
  }

  private buildConfigLoader(): string[] {
    return [
      `async function loadZentestConfig() {`,
      `  try {`,
      `    const configUrl = new URL('../../zentest.config.js', import.meta.url);`,
      `    const loaded = await import(configUrl.href);`,
      `    return (loaded && loaded.default) || loaded || {};`,
      `  } catch {`,
      `    return {};`,
      `  }`,
      `}`,
    ];
  }

  private buildReplayHelpers(): string[] {
    return [
      `async function assertVisibleAtPoint(page, x, y) {`,
      `  const info = await page.evaluate(({ x, y }) => {`,
      `    const element = document.elementFromPoint(x, y);`,
      `    if (!element) return null;`,
      ``,
      `    const style = window.getComputedStyle(element);`,
      `    const rect = element.getBoundingClientRect();`,
      `    const isVisible =`,
      `      style.visibility !== 'hidden' &&`,
      `      style.display !== 'none' &&`,
      `      Number(style.opacity || '1') > 0 &&`,
      `      rect.width > 0 &&`,
      `      rect.height > 0;`,
      ``,
      `    return {`,
      `      isVisible,`,
      `      text: (element.textContent || '').trim(),`,
      `    };`,
      `  }, { x, y });`,
      ``,
      `  expect(info).not.toBeNull();`,
      `  expect(info?.isVisible).toBe(true);`,
      `}`,
      ``,
      `async function fillInputByField(page, field, value, exact = true) {`,
      `  const candidates = [`,
      `    page.getByLabel(field, { exact }),`,
      `    page.getByPlaceholder(field, { exact }),`,
      `    page.getByRole('textbox', { name: field, exact }),`,
      `  ];`,
      `  for (const locator of candidates) {`,
      `    if ((await locator.count()) > 0) {`,
      `      await locator.first().click();`,
      `      await locator.first().fill(value);`,
      `      return;`,
      `    }`,
      `  }`,
      `  throw new Error(\`No input found for field: \${field}\`);`,
      `}`,
    ];
  }

  private buildTestBlock(test: Test, steps: RecordedStep[], navigateFirst: boolean): string[] {
    const lines: string[] = [];

    // Add description comment
    lines.push(...this.buildDescriptionComment(test.description).map(line => `  ${line}`));
    lines.push(`  test('${test.name}', async () => {`);
    lines.push(`    test.setTimeout(20_000);`);

    // Only navigate on first test
    if (navigateFirst) {
      lines.push(`    await page.goto(baseUrl, { waitUntil: 'networkidle' });`);
    }

    const seenAssertions = new Set<string>();
    const hasTextAssertion = steps.some((s) => s.action.type === "assert_text");

    for (const step of steps) {
      // Skip steps that errored during the agentic run - they would fail in static replay too
      if (step.error) {
        continue;
      }

      const code = this.stepToCode(step);
      if (code) {
        // Deduplicate identical assertions
        const isAssertion = step.action.type === "assert_visible" || step.action.type === "assert_text";
        if (hasTextAssertion && step.action.type === "assert_visible") {
          continue; // Prefer text assertions over visibility-only checks
        }
        if (isAssertion && seenAssertions.has(code)) {
          continue; // Skip duplicate assertion
        }

        if (isAssertion) {
          seenAssertions.add(code);
        }

        // Add reasoning as comment, tagged with code origin
        const origin = step.generatedCode ? "[mcp]" : "[vision]";
        if (step.reasoning) {
          lines.push(`    // ${origin} ${step.reasoning.slice(0, 74)}`);
        }
        lines.push(`    ${code}`);
      }
    }

    lines.push(`  });`);
    lines.push(``);

    return lines;
  }

  private buildDescriptionComment(description: string): string[] {
    if (!description) {
      return [`// Generated from: ""`];
    }

    if (!description.includes("\n")) {
      return [`// Generated from: "${description}"`];
    }

    const lines = description
      .split("\n")
      .map((line) => line.trimEnd())
      .filter((line) => line.trim().length > 0);

    if (lines.length === 0) {
      return [`// Generated from: ""`];
    }

    return [
      `/**`,
      ...lines.map((line) => ` * ${line}`),
      ` */`,
    ];
  }

  private stepToCode(step: RecordedStep): string | null {
    // If MCP provided code, use it directly (proper locators like getByRole/getByText)
    // but append waits based on the action type to keep generated tests stable.
    if (step.generatedCode) {
      return step.generatedCode + this.waitForAction(step.action);
    }

    // Fallback to manual code generation
    switch (step.action.type) {
      case "click": {
        // Replay recorded action exactly.
        return `await page.mouse.click(${step.action.x}, ${step.action.y}); await page.waitForTimeout(${this.postClickWaitMs});`;
      }

      case "click_button": {
        const exact = step.action.exact ?? true;
        const click = `await page.getByRole('button', { name: '${this.escapeString(step.action.name)}', exact: ${exact} }).click();`;
        // For submit-like buttons, wait for navigation/network to settle
        const isSubmit = /sign.?in|log.?in|submit|save|confirm|continue|next/i.test(step.action.name);
        const wait = isSubmit
          ? ` await page.waitForLoadState('networkidle').catch(() => {}); await page.waitForTimeout(1000);`
          : ` await page.waitForTimeout(${this.postClickWaitMs});`;
        return click + wait;
      }

      case "click_text": {
        const exact = step.action.exact ?? false;
        return `await page.getByText('${this.escapeString(step.action.text)}', { exact: ${exact} }).first().click(); await page.waitForTimeout(${this.postClickWaitMs});`;
      }

      case "select_input": {
        const exact = step.action.exact ?? true;
        return `await fillInputByField(page, '${this.escapeString(step.action.field)}', '${this.escapeString(step.action.value)}', ${exact});`;
      }

      case "double_click": {
        // Replay recorded action exactly.
        return `await page.mouse.dblclick(${step.action.x}, ${step.action.y}); await page.waitForTimeout(${this.postClickWaitMs});`;
      }

      case "type": {
        // Replay recorded action exactly (type into current focus).
        return `await page.keyboard.type('${this.escapeString(step.action.text)}');`;
      }

      case "key":
        return `await page.keyboard.press('${this.normalizeKeyCombo(step.action.key)}');`;

      case "scroll":
        return `await page.mouse.wheel(0, ${(step.action.amount || 100) * (step.action.direction === "up" ? -1 : 1)});`;

      case "wait":
        if (step.action.ms >= 2000) {
          return `await page.waitForTimeout(${step.action.ms}); await page.waitForLoadState('networkidle').catch(() => {});`;
        }
        return `await page.waitForTimeout(${step.action.ms});`;

      case "assert_visible": {
        return `await assertVisibleAtPoint(page, ${step.action.x}, ${step.action.y});`;
      }

      case "assert_text": {
        // Use .first() to avoid strict mode violations when multiple elements match
        return `await expect(page.getByText('${this.escapeString(step.action.text)}', { exact: false }).first()).toBeVisible({ timeout: 10000 });`;
      }

      case "done":
        return null; // Don't generate code for done actions

      case "mouse_move":
      case "mouse_down":
      case "mouse_up":
      case "drag":
      case "screenshot":
        return null; // These are intermediate actions, don't generate code

      default: {
        // TypeScript exhaustiveness check
        const actionType = (step.action as Action).type;
        return `// ${actionType}: ${step.reasoning}`;
      }
    }
  }

  /**
   * Build the smartest Playwright locator from ElementInfo
   * Priority: data-testid > semantic input locators > native tag+text > role+name > text
   */
  private buildLocator(info: ElementInfo | undefined, action: Action): string | null {
    if (!info) {
      return null;
    }

    // 1. data-testid - most stable, explicit opt-in
    const testIdMatch = info.selector.match(/\[data-testid="([^"]+)"\]/);
    if (testIdMatch) {
      return `page.getByTestId('${testIdMatch[1]}')`;
    }

    // 2. For inputs and textareas: ALWAYS use getByRole/getByLabel/getByPlaceholder, never CSS selectors
    if (info.tagName === "input" || info.tagName === "textarea") {
      const role = info.role || this.inferRoleFromTagName(info.tagName);
      
      // Try getByRole with accessible name (from label, aria-label, or placeholder)
      if (role) {
        const accessibleName = info.ariaLabel || info.name || info.placeholder || null;
        if (accessibleName) {
          return `page.getByRole('${role}', { name: '${this.escapeString(accessibleName)}', exact: true })`;
        }
      }
      
      // Try getByLabel (uses associated label text)
      if (info.name) {
        return `page.getByLabel('${this.escapeString(info.name)}')`;
      }
      
      // Try getByPlaceholder
      if (info.placeholder) {
        return `page.getByPlaceholder('${this.escapeString(info.placeholder)}')`;
      }
      
      // Last resort: getByRole without name (less ideal but still semantic)
      if (role) {
        return `page.getByRole('${role}')`;
      }
      
      // If we can't infer role, return null rather than using CSS selector
      return null;
    }

    // 3. Native tag+text for buttons/links to avoid collisions with custom [role] containers
    const nativeTagLocator = this.buildNativeTagLocator(info);
    if (nativeTagLocator) {
      return nativeTagLocator;
    }

    // 4. role + accessible name fallback for other elements
    const role = info.role || this.inferRoleFromTagName(info.tagName);
    if (role) {
      const accessibleName = this.getPreferredAccessibleName(info, role);
      if (accessibleName) {
        const exact = this.shouldUseExactRoleMatch(role, info, accessibleName);
        return `page.getByRole('${role}', { name: '${this.escapeString(accessibleName)}', exact: ${exact} })`;
      }
    }

    // 5. text content - for non-interactive elements or when no better option
    if (info.text) {
      return `page.getByText('${this.escapeString(info.text)}', { exact: true })`;
    }

    return null;
  }

  /**
   * Infer Playwright role from HTML tag name
   */
  private inferRoleFromTagName(tagName: string): string | null {
    const tag = tagName.toLowerCase();
    switch (tag) {
      case "button":
        return "button";
      case "a":
        return "link";
      case "input":
        // Default to textbox for inputs (most common case)
        // Specific types (checkbox, radio) should be set via info.role
        return "textbox";
      case "textarea":
        return "textbox";
      case "select":
        return "combobox";
      case "checkbox":
      case "input[type='checkbox']":
        return "checkbox";
      case "radio":
      case "input[type='radio']":
        return "radio";
      default:
        return null;
    }
  }

  private getPreferredAccessibleName(info: ElementInfo, role: string): string | null {
    const raw = info.ariaLabel || info.name || info.text || null;
    if (!raw) return null;

    // Link cards often include metadata (date/duration/counters) in the full text content.
    // Prefer the likely title segment so generated locators stay readable and resilient.
    if (role === "link" && !info.ariaLabel) {
      const compact = raw.replace(/\s+/g, " ").trim();
      const titleOnly = this.extractLikelyLinkTitle(compact);
      if (titleOnly) return titleOnly;
      return compact;
    }

    return raw;
  }

  private buildNativeTagLocator(info: ElementInfo): string | null {
    const tag = info.tagName.toLowerCase();
    if (tag !== "button" && tag !== "a") {
      return null;
    }

    const role = info.role || this.inferRoleFromTagName(tag);
    if (!role) {
      return null;
    }

    const accessibleName = this.getPreferredAccessibleName(info, role);
    if (!accessibleName) {
      return null;
    }

    return `page.locator('${tag}', { hasText: '${this.escapeString(accessibleName)}' }).first()`;
  }

  private shouldUseExactRoleMatch(
    role: string,
    info: ElementInfo,
    accessibleName: string
  ): boolean {
    if (role === "link" && !info.ariaLabel) {
      return false;
    }

    return accessibleName.length <= 80;
  }

  private extractLikelyLinkTitle(text: string): string | null {
    const monthRegex =
      /\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{1,2},\s+\d{4},/;
    const monthMatch = text.match(monthRegex);
    if (monthMatch?.index && monthMatch.index > 0) {
      return text.slice(0, monthMatch.index).trim();
    }

    const bulletParts = text
      .split(" • ")
      .map((part) => part.trim())
      .filter(Boolean);
    if (bulletParts.length > 1) {
      return bulletParts[0];
    }

    const counterMatch = text.match(/\s+\d+\s*\/\s*\d+\s*$/);
    if (counterMatch?.index && counterMatch.index > 0) {
      return text.slice(0, counterMatch.index).trim();
    }

    return text || null;
  }

  /**
   * Return a wait suffix for MCP-generated code based on action type.
   * MCP tools handle waits internally during execution, but the generated
   * static code needs explicit waits to remain stable on replay.
   */
  private waitForAction(action: Action): string {
    switch (action.type) {
      case "click":
      case "double_click":
      case "click_text":
        return ` await page.waitForTimeout(${this.postClickWaitMs});`;
      case "click_button": {
        const isSubmit = /sign.?in|log.?in|submit|save|confirm|continue|next/i.test(action.name);
        return isSubmit
          ? ` await page.waitForLoadState('networkidle').catch(() => {}); await page.waitForTimeout(1000);`
          : ` await page.waitForTimeout(${this.postClickWaitMs});`;
      }
      case "select_input":
      case "key":
      case "type":
      case "scroll":
        return "";
      case "wait":
        return "";
      default:
        return "";
    }
  }

  private normalizeKeyCombo(rawKey: string): string {
    const trimmed = rawKey.trim();
    if (!trimmed) return "Enter";

    const hasPlus = trimmed.includes("+");
    const hasDashModifiers =
      /(^|[-])(cmd|command|meta|ctrl|control|alt|option|shift)-/i.test(trimmed);
    const delimiter = hasPlus ? "+" : hasDashModifiers ? "-" : null;
    const parts = delimiter ? trimmed.split(delimiter) : [trimmed];

    const normalized = parts
      .map((part) => {
        const token = part.trim();
        if (!token) return "";
        const lower = token.toLowerCase();
        switch (lower) {
          case "cmd":
          case "command":
          case "meta":
            return "Meta";
          case "ctrl":
          case "control":
            return "Control";
          case "alt":
          case "option":
            return "Alt";
          case "shift":
            return "Shift";
          case "esc":
            return "Escape";
          case "return":
            return "Enter";
          case "space":
          case "spacebar":
            return "Space";
          case "del":
            return "Delete";
          default:
            return token.length === 1 ? token.toUpperCase() : token;
        }
      })
      .filter(Boolean);

    return normalized.join("+") || "Enter";
  }

  /**
   * Escape special characters in strings for JavaScript
   */
  private escapeString(str: string): string {
    return str
      .replace(/\\/g, "\\\\")
      .replace(/'/g, "\\'")
      .replace(/\n/g, "\\n")
      .replace(/\r/g, "\\r")
      .replace(/\t/g, "\\t");
  }
}

